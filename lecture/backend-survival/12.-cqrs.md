# 12. CQRS

* CQS (Command Query Separation)
  * 일반적인 객체는 시간에 따라 변하는 상태를 가짐
  *   메서드(연산)은 캡슐화된 상태를 변화시키는 유일한 수단

      \-> 우리가 프로그램을 사용하는 이유
  *   언제 어떻게 상태가 변하는지 예측하기 힘들다면, 프로그램을 사용하기 힘들고, 유지보수에 어려움

      \-> 상태를 변경하지 않고 상태를 알 수 있는, side-effect가 없는 메서드를 따로 분리

      \-> 상태를 변경하는 메서드에서 상태를 리턴하지 않게 하면 확실히 분리 가능
  * 상태를 변경하지 않고 상태를 얻는 메서드를 Query
  *   상태를 변경하고 상태를 돌려주지 않는 메서드를 Command

      \-> 이 둘을 잘 나누는 건 메서드 단위의 적극적인 SRP기도 하고, 순수 함수와 함수형 도구를 활용하기 위한 준비 과정
  * 적절하게 제약을 건다면 CRUD는 동시에 실행되지 않고 개별적으로 실행
  *   CUD는 Command, R은 Query라고 볼 때 도메인 지식과 비즈니스 로직은 Command에 집중

      \-> Query에 상태를 바꾸지 않는 고수준의 순수 함수를 집중할 수도 있지만, 이런 경우는 SRP에 따라 분리되거나 객체 외부에서 함수형 기법을 활용하게 될 가능성이 큼



* CQRS (Command Query Responsibility Segregation)
  * 비즈니스 로직은 복잡하고 고려해야 할 게 많음
  *   Write Model, Read Model 구분

      * 적절한 도메인 모델, 객체 등 객체지향 기술을 적극 활용해서 복잡성을 통제해야 함
      *   도메인 지식이 얼마나 잘 반영되었는지, 이를 어떻게 쉽게 검증할 수 있는지, 얼마나 유지보수하기 용이한지 등에 무게를 두어야 함

          \-> 어플리케이션의 상태를 변경하는 일, Command에 해당
      * 사용자에게 보여주는 부분을 이미 끝난 일에 해당할 때가 많음
      *   상태를 변경시키는 일은 없지만, 많은 사용자가 자주 사용하는 부분이기 때문에 성능 등에 무게를 두어야 함

          \-> 사용자에게 보기 좋은 형태로 미리 준비하면 도움이 됨, Query에 해당

      \=> Command가 실행된 후(어플리케이션의 상태 변경) 거의 바로 Read Model을 업데이트 한다면, Command와 Query가 명확히 구분되고 트래픽 등이 비댕칭적으로 발생하는 대부분의 서비스에 도움이 됨
  * &#x20;Write Model은 특정한 기술이 정의되지 않음
  * Read Model은 상황에 맞게 적절한 기술을 통해 존재
    * Materialized View : 몇몇 RDBS에서 읽기 성능을 향상시킬 목적으로 물리적으로 저장되고, 주기적으로 동기화가 이루어지는 View생성
    * OLTP(Online Transaction Processing) & OLAP(Online Analytical Processing)&#x20;
      * OLTP(Online Transaction Processing) : 트랜젝션 처리를 위한 최적화(ex 정규화)
      * OLAP(Online Analytical Processing)  :  의사결정에 필요한 데이터 분석(ex 반정규화)
    *   Event Sourcing : 상태의 변화를 이벤트의 연속으로 다루는 방식, 이력을 모아서 현재의 상태를 계산

        \-> Event가 누적될수록 현재 상태를 빠르게 조회하거나 분석하기에는 어려워 CQRS와 함께 사용됨

